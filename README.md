# HRT Journey Tracker — Workspace README

This workspace contains two small Windows desktop apps being developed in parallel:

- **Journey Journal** (`Journey Journal/`) — journaling-focused app
- **TrackMyHRT** (`TrackMyHRT/`) — HRT tracking-focused app

Both apps are separate, iterative projects. The goal is to experiment, refine, and stabilize features independently, then merge or consolidate them into a single finished application once the direction is clear.

- **Target environment:** Windows + Python launcher (`py`) + VS Code
- **Packaging:** PyInstaller (each app has its own `.spec` file and assets)

## What this workspace is (and isn’t)

### ✅ This workspace is

- A place to develop each app independently while features evolve
- A sandbox for experiments, prototypes, and mini-features
- A workspace for repeatable PyInstaller builds and packaging notes

### ❌ This workspace is not (yet)

- A single unified app with a stable architecture
- A polished release pipeline
- A finalized or fully optimized codebase (expect refactors as features converge)

## Folder structure (current)

```text
HRT Journey Tracker/
├─ Journey Journal/
│  ├─ JJ.py
│  ├─ Journey Journal.spec
│  ├─ assets/
│  │  └─ jj.ico
│  └─ build/                   # generated by PyInstaller (do not commit)
│     └─ Journey Journal/
│        └─ ...
├─ TrackMyHRT/
│  ├─ HRT.py
│  ├─ TrackMyHRT.spec
│  ├─ TrackMyHRT.md
│  ├─ roadmap.md
│  ├─ assets/
│  │  └─ HRT.ico
│  └─ build/                   # generated by PyInstaller (do not commit)
│     └─ TrackMyHRT/
│        └─ ...
└─ README.md                   # this file
```

**Notes:**
- Each app is self-contained with its own `assets/` and `.spec`.
- `build/` and `dist/` folders are generated during packaging and should not be committed.

## Requirements

### Development

- Windows 10/11
- Python 3.x via the Windows launcher (`py`)
- VS Code (recommended)

### Packaging

Install PyInstaller:

```powershell
py -m pip install --upgrade pyinstaller
```

If using a virtual environment, install PyInstaller inside that venv.

## Quick start (developer)

### (Optional) Create a virtual environment at the workspace root

```powershell
py -m venv .venv
.\.venv\Scripts\Activate.ps1
py -m pip install --upgrade pip
py -m pip install --upgrade pyinstaller
```

### Run Journey Journal (dev)

```powershell
py ".\Journey Journal\JJ.py"
```

### Run TrackMyHRT (dev)

```powershell
py ".\TrackMyHRT\HRT.py"
```

### Run the Launcher (dev)

```powershell
py ".\Launcher.py"
```

## Packaging (PyInstaller)

Both apps support two build methods:

- Using the `.spec` file — best for stable, repeatable builds
- Using command-line options — convenient while experimenting

### Journey Journal

#### Build from command line

```powershell
py -m PyInstaller --noconfirm --clean --windowed --name "Journey Journal" --icon ".\Journey Journal\assets\jj.ico" ".\Journey Journal\JJ.py"
```

#### Build from spec (recommended)

```powershell
py -m PyInstaller --noconfirm --clean ".\Journey Journal\Journey Journal.spec"
```

**Expected outputs:**
- EXE: `.\dist\Journey Journal\Journey Journal.exe`
- Build artifacts: `.\build\...` or `Journey Journal\build\...` depending on settings

### TrackMyHRT

#### Build from command line

```powershell
py -m PyInstaller --noconfirm --clean --windowed --name "TrackMyHRT" --icon ".\TrackMyHRT\assets\HRT.ico" ".\TrackMyHRT\HRT.py"
```

#### Build from spec (recommended)

```powershell
py -m PyInstaller --noconfirm --clean ".\TrackMyHRT\TrackMyHRT.spec"
```

**Expected outputs:**
- EXE: `.\dist\TrackMyHRT\TrackMyHRT.exe`
- Build artifacts: `.\build\...` or `TrackMyHRT\build\...`

## Cleaning build artifacts

### Workspace-root `build/` and `dist/`

```powershell
Remove-Item -Recurse -Force .\build, .\dist -ErrorAction SilentlyContinue
Remove-Item -Force .\*.spec -ErrorAction SilentlyContinue
```

### App-local build folders

```powershell
Remove-Item -Recurse -Force ".\Journey Journal\build" -ErrorAction SilentlyContinue
Remove-Item -Recurse -Force ".\TrackMyHRT\build" -ErrorAction SilentlyContinue
```

Keep the `.spec` files inside each app folder if you rely on them.

## Icons (EXE icon in Explorer)

Each app includes its own icon:

- `Journey Journal/assets/jj.ico`
- `TrackMyHRT/assets/HRT.ico`

### Recommended ICO structure

For best compatibility on Windows:

- Valid ICO file (not a renamed PNG)
- Contains: 16×16, 32×32, 48×48, 256×256
- 32-bit RGBA with alpha
- 256×256 entry included (PNG-compressed is normal)

### If Explorer shows the wrong icon

Windows may be using a cached version.

Restart Explorer:

```powershell
taskkill /f /im explorer.exe
start explorer.exe
```

Clear icon cache:

```powershell
ie4uinit.exe -ClearIconCache
taskkill /f /im explorer.exe
Remove-Item "$env:LOCALAPPDATA\IconCache.db" -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Microsoft\Windows\Explorer\iconcache*" -ErrorAction SilentlyContinue
start explorer.exe
```

## Launcher (workspace app picker)

The workspace includes a **Launcher** app (`Launcher/Launcher.py`) that scans the workspace and shows a button for each “launchable” app it discovers.

### What the Launcher does
- **Auto-discovers apps** by scanning the workspace root subfolders.
- Shows a simple **Apps** panel with one button per discovered app.
- Tracks **Recent activity** (when each app was last opened) via **QSettings**.
- Runs quick **diagnostics** before launching to surface common issues early (syntax errors, missing dependencies).
- Supports **keyboard shortcuts** for refresh/open/quit and per-app launch.

### Discovery rules (how it finds apps)
The Launcher scans folders under the workspace root (default max depth: **2**) and ignores known non-app folders like:
- `launcher`, `.git`, `__pycache__`, `build`, `dist`, `storage`, `assets`, `.venv`, `venv`

It also ignores some common non-entry files like:
- `__init__.py`, `setup.py`, `conftest.py`

### Entry script selection heuristic (important)
For each candidate app folder, the Launcher picks an entry script deterministically (to avoid launching random helper modules):

Priority order:
1. **`<FolderName>.py`** (ignoring spaces / `_` / `-` differences)  
   Example: folder `TrackMyHRT/` → prefers `TrackMyHRT/HRT.py` only if it matches folder name normalization rules; otherwise falls back to the next rules.
2. Otherwise, one of these common entrypoint names if present:
   - `main.py`, `app.py`, `run.py`
3. Otherwise, if there is **exactly one** `*.py` file at the folder root, it uses that.

Depth-2 fallback:
- If a top-level folder doesn’t contain an entry script, the Launcher can look **one folder deeper** and use a nested entry script **only if exactly one nested candidate is found**.

### Diagnostics (what “Status” is checking)
Before launching, the Launcher runs:
- `python -m py_compile <script>` to catch syntax/import-time errors
- `python -c "import PySide6"` to detect a missing PySide6 dependency

If something fails, the Launcher shows a clear error dialog explaining what to fix.

### Shortcuts
Global:
- **F5**: Refresh discovered apps
- **Alt+O**: Open workspace folder
- **Ctrl+Q**: Quit Launcher

Per-app:
- The Launcher attempts to assign **Alt+<letter>** shortcuts automatically based on the app name (first unused A–Z letter).

### Notes / limitations
- Launching uses the **current Python interpreter** (`sys.executable`).
- The launched app’s **working directory** is set to the script’s folder.
- The Launcher can prompt before starting **duplicate instances** of the same app.

## Development approach (why two apps)

While the final combined app is still being shaped:

- **TrackMyHRT** focuses on structured tracking workflows
- **Journey Journal** focuses on journaling UX and UI experimentation

Once features stabilize, the plan is to:

- consolidate shared functionality,
- unify the project structure,
- and standardize packaging + dependencies.

## A personal note

Thank you for checking out this project. Contributions, suggestions, and improvements are always welcome.

This is a passion project for me — both as a trans woman who wants to offer a free, accessible tool for the trans community, and as someone who genuinely loves coding and hopes to build software professionally. If this project helps even one person feel more supported on their journey, it’s worth every line of code.